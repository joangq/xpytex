# Welcome to xpytex!



This library tries to simplify Python-to-LaTeX translation. It's goal is to be flexible and extensible.

It uses the generated Python [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) to generate string with LaTeX code. It heavily depends on the current syntax of Python, and therefore on the output generated by the `ast` module parser.
## How it works



The library has `handlers`, each handler converts a certain type (or portion) of the AST to LaTeX. Because the [syntax is mutually recursive](https://en.wikipedia.org/wiki/Recursive_descent_parser), the handlers also are mutually recursive.



For example, `Expressions`, and more specifically `Binary Operations`.



A binary operation can be defined as:



```java 

<expression> ::= ...

               | ...

               | <binary_operation>



<binary_operation> ::= <expression> <binary_operator> <expression>

```



Using [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) metasyntax.



In `xpytex`, that get's reflected by the fact that the `expressions` handler will call to the `binary_operations` handler, which will partially convert the AST into a string, but then it needs help with the other expressions.



Say we have the expression `"A+2"`. Then, the corresponding AST should look something like:



```

expression

└── binary_operation

    ├── name

    │   └── A

    ├── binary_operator

    │   └── Add()

    └── constant

        └── 2

```



Then, the `binary_operations` handler could provide a symbol for `Add()` but will need the result of `expressions.latexify` for the right `name`, and `constant` members. Then `expression` calls `name` and `constant` with the corresponding subtrees, and each can successfully return a string for their parts. Finally, all the recursion gets solved and a single string `"A+2"` is returned.



**As mentioned early, this library _heavily_ depends on Python syntax and parser. If the syntax changes, then the handlers must be changed as well.**



Nonetheless, the library as a whole tries to be as decoupled as possible, so if the same principles are followed, conversion shouldn't be that big of a deal.

```python
from xpytex import latexify

from xpytex.utils import displaymath



displaymath( latexify('a+2+2*3 or A.foo(x) and A.b and a != b == c is d is not e + Secuencia.de(1,2,3) + np.array([[1,2,3], [4,5,6]])') )
```

$$
\displaystyle a+2+2\times{}3 \lor{} \text{A}.foo(x) \land{} \text{A}.\text{b} \land{} a {\neq}\_{\text{obs}} b {=}\_{\text{obs}} c \equiv{} d \not\equiv{}e+\left\langle{}1, 2, 3\right\rangle{}+\left[\begin{matrix}1 & 2 & 3\\\\4 & 5 & 6\end{matrix}\right]
$$
